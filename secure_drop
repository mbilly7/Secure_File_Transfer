#!/usr/bin/env python3

from email_validator import validate_email, EmailNotValidError
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import _pickle as cPickle
import bcrypt
import json
import os
import re
import sys
import ssl
import socket
<<<<<<< HEAD
import time
=======
>>>>>>> abf0bd6 (remove progress bar from receive_file(), there is a connection error in line 617)
from time import sleep
from multiprocessing import Process, Queue
from socketserver import BaseRequestHandler, TCPServer
import getpass
import subprocess
from threading import Thread
from os import chmod

own_ip = None
SYMM_KEY = "stub"
<<<<<<< HEAD

# TODO:
# - Adding
#     - Mutual adding only
#     - Add only if both are online & certs trusting
# - Sending
# - Certificates signed by CA

=======
HOST_IP = "127.0.0.1"
MSG = "temp"
>>>>>>> dd7f64f (work in progress: capture messages)

# # # # # 1. SHELL COMMANDS # # # # #


def secureDropShell():
    while True:
        inp = input("secure_drop> ")
        if inp == "exit":
            break
        elif inp == "help":
            shell_help()
        elif inp == "add":
            shell_add()
        elif inp == "list":
            shell_list()
        elif inp == "send":
            print("Did not provide enough arguments. Syntax: send <email> <file_path>.")
        elif inp[:5] == "send ":
            words = inp.split()

            email_valid = False
            file_path_valid = False

            if len(words) != 3:
                print("Did not provide enough arguments. Syntax: send <email> <file_path>.")

            else:
                email = words[1]
                file_path = words[2]
                
                # Check if email is contacts
                if os.path.getsize("contacts.bin") > 0:
                    if not isInContacts(email):
                        print("The provided email address is not in your contacts list.")
                    else:
                        email_valid = True
                try:
                    if os.path.getsize(file_path) == 0:  # change criteria later?
                        print("The provided file is empty.")
                    else:
                        file_path_valid = True

<<<<<<< HEAD
                except FileNotFoundError:
                    print("The provided file path does not exist.")
=======
            # Check if email is contacts
            if os.path.getsize("contacts.bin") > 0:
                if not isInContacts(email):
                    print("provided email address is not in your contacts list")
                else:
                    email_valid = True
                    print("email correct")  # debug
<<<<<<< HEAD
>>>>>>> 9c54801 (Add some comments with VSCode Extension BetterComments)

                if email_valid and file_path_valid:
                    shell_send(email, file_path)
=======
            try:
                if os.path.getsize(file_path) == 0:  # change criteria later?
                    print("provided file is empty")
                else:
                    file_path_valid = True
                    print("file correct")  # debug

            except FileNotFoundError:
                print("provided file path does not exist")
>>>>>>> 2e37c75 (handle FileNotFoundError)

        else:
            execute_command(inp)


def shell_help():
    print('  "add"  -> Add a new contact')
    print('  "list" -> List all online contacts')
    print('  "send" -> Transfer file to contact')
    print('  "exit" -> Exit SecureDrop')


def shell_add():
    name = getName()
    email = getEmail()
    # TODO: Make sure contact is online
    # TODO: Make sure that they have the trusted certificate
    storeData(name, email, "contacts.txt")
    print("  Contact Added.")


def shell_list():
    if os.path.getsize("contacts.bin") > 0:
<<<<<<< HEAD
<<<<<<< HEAD
        broadcast_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        broadcast_socket.bind(('', 5001))

        q = Queue()

        broadcast_listener_worker = Process(target=broadcast_listener,
                                            name="broadcast_listener_worker",
                                            args=(broadcast_socket, q, ))

        broadcast_listener_worker.start()
        receivedEmails = []
        print("The following contacts are online:")

        temp = 5

        while broadcast_listener_worker.is_alive() and temp != 0:
            data = q.get()
            email = data[0].decode().split(" ")[0]
            ip_addr = data[1][0]

            name = getNameFromEmail(email)

            if isInContacts(email) and email not in receivedEmails:
                receivedEmails.append(email)
                print("* " + name + " <" + email + ">")

            temp = temp - 1
            
        # broadcast_listener_worker.join() #TODO: do we need this?
        broadcast_listener_worker.terminate()

=======
        if len(sys.argv) > 1:
            sendEmailRequest(9990)
        else:
            sendEmailRequest(9995)
>>>>>>> d1e287e (Fix listing port issue)
=======
        print("blah blah.")
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)
    else:
        print("You have no contacts.")


def shell_send(email, file_path):
<<<<<<< HEAD
<<<<<<< HEAD
=======
    print("  Sending!")
    if len(sys.argv) > 1:
        communication_manager()
    else:
        communication_manager(True)
#    send_file(file_path)
>>>>>>> dd7f64f (work in progress: capture messages)
=======
    # print("  Sending!")
    # if len(sys.argv) > 1:
    #     communication_manager()
    # else:
    #     communication_manager(True)
    send_file(file_path)
>>>>>>> 2247660 (Remove tqdm progress bar for sending.)

    global own_ip
    
    #strech: hash messages
    broadcast_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    broadcast_socket.bind(('', 5001))
    
    #send initial broadcast message that includes your ID (in the form of IP and port)
    #broadcast_sender_worker_for_files = Process(target=broadcast_sender_for_files,
                                                #name="broadcast_sender_worker_for_files",
                                                #args=(5001,True,))
    #broadcast_sender_worker_for_files.start()
    # receive receiver's response that includes their ID (in the form of IP and port)
    q = Queue()
    broadcast_listener_worker = Process(target=broadcast_listener,
                                                name="broadcast_listener_worker",
                                                args=(broadcast_socket,q,))
    broadcast_listener_worker.start()

    # We need the receiver's IP address in order to send them the file.
    # We get this from the message that they broadcast to us in response to the
    # initial broadcast we send to them above.
    # Since all online users are broadcasting, we have to make sure that we identify
    # the correct response broadcast.
    # Our conditions (besides the listener process being alive) are:
    # - The email in the received broadcast is the email of the person we're trying
    # to send a file to.
    # Note: The receiver email and IP address are set to our own email and IP address
    # at first and are later replaced by the actual receiver's email and IP address.

    receiver_email = getEmailFromCredentials()
    receiver_ip_addr = own_ip

    while broadcast_listener_worker.is_alive() and receiver_email != email:
        data = q.get()
        receiver_email = data[0].decode().split(" ")[0]
        receiver_ip_addr = data[1][0]

    # Send the file over the encrypted TLS connection
    send_file(file_path, receiver_ip_addr)

    #kill processes
    #broadcast_sender_worker_for_files.terminate()
    #broadcast_listener_worker_for_files.terminate()

def execute_command(command):
    """execute commands and handle piping"""
    try:
        if "|" in command:
            # save for restoring later on
            s_in, s_out = (0, 0)
            s_in = os.dup(0)
            s_out = os.dup(1)

            # first command takes commandut from stdin
            fdin = os.dup(s_in)

            # iterate over all the commands that are piped
            for cmd in command.split("|"):
                # fdin will be stdin if it's the first iteration
                # and the readable end of the pipe if not.
                os.dup2(fdin, 0)
                os.close(fdin)

                # restore stdout if this is the last command
                if cmd == command.split("|")[-1]:
                    fdout = os.dup(s_out)
                else:
                    fdin, fdout = os.pipe()

                # redirect stdout to pipe
                os.dup2(fdout, 1)
                os.close(fdout)

                try:
                    subprocess.run(cmd.strip().split())
                except Exception:
                    print("Command not found: {}. Type `help` to view valid commands.".format(cmd.strip()))

            # restore stdout and stdin
            os.dup2(s_in, 0)
            os.dup2(s_out, 1)
            os.close(s_in)
            os.close(s_out)
        else:
            subprocess.run(command.split(" "))
    except Exception:
        print("Command not found: {}. Type `help` to view valid commands.".format(command))


############################################################
#          MILESTONE 1: USER REGISTRATION                  #
############################################################
# # # # # 2. Credentials (MS 1-2) # # # # #


def getEmail():
    while True:
        try:
            email = str(input("Enter Email Address: "))
            validate_email(email)
            return email
        except EmailNotValidError as e:
            print(str(e))
            continue
        else:
            break


def getName():
    name = input("Enter Full Name: ")
    while not all(x.isalpha() or x.isspace() for x in name) or len(name) == 0:
        print("Invalid Name. Try again.")
        name = input("Enter Full Name: ")
    return name


# # # # # 2.1 Credentials - Password (MS 1-2) # # # # #


def setPassword():
    password = getpass.getpass()
    while not passwordMeetsRequirements(password):
        print("""Password must be 6-20 characters long and requires at least one: 
    number, uppercase letter, lowercase letter, and special symbol. Try again.""")
        password = getpass.getpass()

    password_copy = getpass.getpass("Re-enter Password: ")
    if password_copy != password:
        print("Passwords do not match. Try again.")
        password = setPassword()
    return password


def getPassword():
    password = getpass.getpass()
    return password


def getHashedPassword(password):
<<<<<<< HEAD
    # TODO: CHANGE TO 16 IN FINAL PRODUCT
=======
    # CHANGE TO 16 IN FINAL PRODUCT
>>>>>>> bd75a18 (Found out the problem. We need to store data captured in a seperate file (maybe a temp file))
    return bcrypt.hashpw(password.encode("utf8"), bcrypt.gensalt(12))


def passwordMeetsRequirements(password):
    reg = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!#%*?&]{6,20}$"
    return re.search(re.compile(reg), password)


def checkPassword(password, hashed_password):
    """
    :param password: the string representation of the password in plain-text or None
    :type password: str or None
    :param hashed_password: the string representation of the hashed password
    :type hashed_password: str
    :returns: True if the password is correct or False if the password is incorrect
    :rtype: bool
    """
    if password is None:
        return False
    return bcrypt.checkpw(password.encode("utf8"), hashed_password.encode("utf8"))

#####################################################
#          MILESTONE 2: USER LOGIN                  #
#####################################################


def logIn():
    global SYMM_KEY
    successful = False
    if os.path.getsize("credentials.txt") > 0:
        touch("contacts.bin")
        chmod("contacts.bin", 0o600)
        email = getEmail()
        password = getPassword()

        # check password correctness by parsing credentials.txt
        with open("credentials.txt") as json_file:
            data = json.load(json_file)
            for user in data["users"]:
                if user["email"] == email and checkPassword(password, user["password"]):
                    SYMM_KEY = user["password"][3:19].encode("utf-8")
                    # successful
                    print("Passwords Match.")
                    print("Logging In.")
                    successful = True
                    # *TODO: Enter shell
                if not successful:
                    print("Email and Password Combination Invalid.")
                    successful = logIn()
    else:
        print("There are no users registered.")

    return successful


def storeUserInfo(name, email, password):
    """
    returns the dict of dict that constitutes the user info
    the outer dictionary maps the string "users" to a dictionary
    the inner dictionary maps the strings "name", "email", and "password" to strings for all three of these
    """
    data = {}
    data["users"] = []

    user_dict = {}

    user_dict["name"] = name
    user_dict["email"] = email
    user_dict["password"] = getHashedPassword(password).decode("utf-8")

    data["users"].append(user_dict)
    return data

#####################################################
#          MILESTONE 3: ADDING CONTACTS             #
#####################################################

# # # # # 7. Encryption # # # # #


def aesEncryptFile(file_name, key):
    cipher = AES.new(key, AES.MODE_EAX)
    data = open(file_name, 'rb').read()
    ciphertext, tag = cipher.encrypt_and_digest(data)

    file_name = file_name.replace(".txt", "")
    file_name += ".bin"
    file_out = open(file_name, "wb")
    [file_out.write(x) for x in (cipher.nonce, tag, ciphertext)]
    file_out.close()
    chmod(file_name, 0o600)
    os.remove("contacts.txt")


def aesDecryptFile(file_name, key):
    file_in = open(file_name, "rb")
    nonce, tag, ciphertext = [file_in.read(x) for x in (16, 16, -1)]
    cipher = AES.new(key, AES.MODE_EAX, nonce)
    file_name = file_name.replace(".bin", "")
    file_name += ".txt"
    file_out = open(file_name, "wb")
    file_out.write(cipher.decrypt_and_verify(ciphertext, tag))
    chmod(file_name, 0o600)
    return file_name

# # # # # 4. Database # # # # #


def storeData(name, email, filename):
    global SYMM_KEY
    if os.path.getsize("contacts.bin") > 0:
        aesDecryptFile("contacts.bin", SYMM_KEY)
    else:
        touch("contacts.txt")
        chmod("contacts.txt", 0o600)

    db = {}

    newContact = {'name': name, 'email': email}

    db[name] = newContact

    dbfile = open(filename, 'ab')

    cPickle.dump(db, dbfile)
    dbfile.close()

    aesEncryptFile(filename, SYMM_KEY)


def isInContacts(data):
    exists = False
    contacts = getObjs("contacts.txt")
    for x in contacts:
        for y in x:
            if x[y]["email"] == data:
                exists = True
    return exists

<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
=======

>>>>>>> d29135a (Update)
def getEmailFromCredentials():
    with open("credentials.txt") as json_file:
        data = json.load(json_file)
        for user in data["users"]:
            email = user["email"]
    return email
>>>>>>> d1e287e (Fix listing port issue)


def getObjs(filename):
    global SYMM_KEY
    aesDecryptFile("contacts.bin", SYMM_KEY)

    objs = []
>>>>>>> bd75a18 (Found out the problem. We need to store data captured in a seperate file (maybe a temp file))

#{'bob': {'name': 'bob', 'email': 'bob@gmail.com'}}
def getNameFromEmail(email):
    contacts = getObjs("contacts.txt")
    for x in contacts:
        for y in x:
            if x[y]["email"] == email:
                return x[y]["name"]
    return "MR. BEAN"

<<<<<<< HEAD
def getNameFromCredentials():
    with open("credentials.txt") as json_file:
        data = json.load(json_file)
        for user in data["users"]:
            name = user["name"]
    return name
=======
    print(objs)
    dbfile.close()
>>>>>>> 9c54801 (Add some comments with VSCode Extension BetterComments)

def getEmailFromCredentials():
    with open("credentials.txt") as json_file:
        data = json.load(json_file)
        for user in data["users"]:
            email = user["email"]
    return email


def getObjs(filename):
    global SYMM_KEY
    aesDecryptFile("contacts.bin", SYMM_KEY)

    objs = []

    with (open(filename, "rb")) as dbfile:
        while True:
            try:
                objs.append(cPickle.load(dbfile))
            except EOFError:
                break

    dbfile.close()

    aesEncryptFile("contacts.txt", SYMM_KEY)
    return objs


def registerNewUser():
    if os.path.exists("contacts.bin"):
        os.remove("contacts.bin")

    print("The user registration is a one-time process. Once a user is registered on a client, the"
          " login module is activated subsequently. After a successful login, a \"secure_drop>\" shell"
          " is started.")

    name = getName()
    email = str(getEmail())
    password = setPassword()

    dumpRegisterToTextFile(storeUserInfo(
        name, email, password), "credentials.txt")


def dumpUserToTextFile(data, file_name):
    """
    data is a dict of dict
    """
    with open(file_name, "w") as outfile:
        cPickle.dump(data, outfile)


def dumpRegisterToTextFile(data, file_name):
    with open(file_name, "w") as outfile:
        json.dump(data, outfile)


# # # # # 6. CLI # # # # #

def query_binary(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " (y/n)? "
    elif default == "yes":
        prompt = " (Y/n)? "
    elif default == "no":
        prompt = " (y/N)? "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        print(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            print("Please respond with 'yes' or 'no' "
                  "(or 'y' or 'n').")


def touch(fname):
    if os.path.exists(fname):
        os.utime(fname, None)
    else:
        open(fname, 'a').close()


def init_ip():
    global own_ip
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 80))
    own_ip = s.getsockname()[0] 
    #host = "localhost"
    s.close()


###########################################################
#          MILESTONE 5: SECURE FILE TRANSFER              #
###########################################################

class tcp_handler(BaseRequestHandler):
    def handle(self):
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
       self.data = self.request.recv(1024).strip()
       receive_file(self.data)
       print("Echoing message: {}", self.data)#temp

       if len(self.data.decode().split("$!%")) == 2:
           query_msg = self.data.decode().split("$!%")[0]
           ip_addr = self.data.decode().split("$!%")[1]
           tcp_client(6001, str(query_binary(query_msg)).encode(), ip_addr)
           
       #print("")
       self.request.sendall("ACK from server".encode())
=======
        global MSG
        self.data = self.request.recv(1024).strip()
=======
>>>>>>> 6c3e54a (remove init() from tcp_handler)

=======
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)
        self.data = self.request.recv(1024).strip()
        print("Echoing message from: {}".format(self.client_address[0]))
        print(self.data)
        self.request.sendall("ACK from server".encode())
>>>>>>> dd7f64f (work in progress: capture messages)


def tcp_listener(port):
    global own_ip
    host = own_ip
    cntx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    cntx.load_cert_chain('cert.pem', 'cert.pem')

    server = TCPServer((host, port), tcp_handler)
    server.socket = cntx.wrap_socket(server.socket, server_side=True)
    try:
        server.serve_forever()
    except:
        server.shutdown()

<<<<<<< HEAD

def tcp_client(port, data, target_ip):
=======
def tcp_client(port, data):
<<<<<<< HEAD
    host_ip = "127.0.0.1"

>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)
=======
    # TODO: MAYBE CHANGE host_ip TO DOCKER CONTAINER IP
    #host_ip = "127.0.0.1"
    host_ip = "172.17.0.2"
    
>>>>>>> 80442f2 (Test threading)
    # Initialize a TCP client socket using SOCK_STREAM
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    cntx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    cntx.load_verify_locations('cert.pem')
    cntx.load_cert_chain('cert.pem')

    s = cntx.wrap_socket(s, server_hostname='test.server')

    try:
        # Establish connection to TCP server and exchange data
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
        # TODO: FIX ERROR RELATED TO THE FOLLOWING LINE
        s.connect((target_ip, port))
        s.sendall(data)
        # Read data from the TCP server and close the connection
        received = s.recv(1024)
    finally:
        s.close()

=======
        result = s.connect_ex((HOST_IP, port))
        #print("RESULT: ", result)
        if result == 0:
            s.sendall(data.encode())
            # Read data from the TCP server and close the connection
            received = s.recv(1024)
        else:
            print("No contacts online.")
=======
=======
        # TODO: FIX ERROR RELATED TO THE FOLLOWING LINE
>>>>>>> 80442f2 (Test threading)
        s.connect((host_ip, port))
        s.sendall(data.encode())
        # Read data from the TCP server and close the connection
        received = s.recv(1024)
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)
    finally:
        s.close()

    print("Bytes Sent:     {}".format(data))
    print("Bytes Received: {}".format(received.decode()))
<<<<<<< HEAD
    '''
>>>>>>> d1e287e (Fix listing port issue)
=======

>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)

#######################################
#          Broadcast Example          #
#######################################
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD

def broadcast_listener(socket, q):
    try:
        while True:
            data = socket.recvfrom(512)
            #print(data)
            q.put(data)
            email = data[0].decode().split(" ")[0]
            ip_addr = data[1][0]
            
            if os.path.getsize("credentials.txt") > 0:
                name = getNameFromCredentials()

            # Received a send request,
            if data[0].decode().split(" ")[1] == 'True':
                msg = "Contact '" + name +  " <" + email + ">' is sending a file. Accept" + "$!%" + own_ip
                tcp_client(6001, msg.encode(), ip_addr)

                #email = data[0].decode().split(" ")[0]
                           
                if query_binary():
                    print("todo: they accepted")
                else:
                    print("todo: they declined")

=======
=======


>>>>>>> d29135a (Update)
=======
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)
def broadcast_listener(socket):
    try:
        while True:
            data = socket.recvfrom(512)
<<<<<<< HEAD
            print(data)
<<<<<<< HEAD
            print("THIS WAS THE MOST RECENTLY SENT MESSAGE")
            print(MSG)
>>>>>>> dd7f64f (work in progress: capture messages)
=======
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)
=======
            #print(data)
>>>>>>> 1477335 (Remove bcast_test)
    except KeyboardInterrupt:
        pass

def broadcast_sender(port, is_for_files=False):
    count = 0
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        while True:
<<<<<<< HEAD
            msg = getEmailFromCredentials() + " " + str(is_for_files)
            # The third tuple element is a boolean that indicates whether or
            # not the sender is attempting to send a file.
            # TODO: Hash the ID's if we have time
            s.sendto(msg.encode('ascii'), ('255.255.255.255', port))
=======
            msg = 'bcast_test: ' + str(count)
            count += 1
<<<<<<< HEAD
            #s.sendto(msg.encode('ascii'), ('255.255.255.255', port))
>>>>>>> d1e287e (Fix listing port issue)
=======
            s.sendto(msg.encode('ascii'), ('255.255.255.255', port))
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)
            sleep(5)
    except KeyboardInterrupt:
        pass

##########################################################
#        Milestone 5: Secure File Transfer               #
##########################################################


#precondition: a valid filename
def send_file(filename, receiver_ip_addr):

    SEPARATOR = "<SEPARATOR>"

<<<<<<< HEAD
    # the name of file we want to send, make sure it exists
    filesize = os.path.getsize(filename)

    # the data contains the filename and filesize
    data = f"{filename}{SEPARATOR}{filesize}{SEPARATOR}"
    
    # Convert the file in the file path to a bytes object
    with open(filename, 'rb') as f:
        # TODO: Maybe add buffer size as arg to read()
        contents = f.read().decode()
        data += contents

        # Send it to the port via tcp_client

        tcp_client(6001, data.encode(), receiver_ip_addr)
=======
    # * receiver IP Address and Port
    host = HOST_IP
    print("IMPORTANT!")
    print(len(sys.argv))
    if len(sys.argv) > 1:
        port = 5001
    else:
        port = 5002

    # the name of file we want to send, make sure it exists
    filename = file_path
    filesize = os.path.getsize(filename)

    # create the client socket
    s = socket.socket()

    print(f"[+] Connecting to {host}:{port}")
    s.connect((host, port))
    print("[+] Connected.")

    # send the filename and filesize
    s.send(f"{filename}{SEPARATOR}{filesize}".encode())

    # * start sending the file
    with open(filename, "rb") as f:
        # read the bytes from the file
        bytes_read = f.read(BUFFER_SIZE)

#        if not bytes_read:
            #file transmitting is done
#            break
        
        # send file
        s.sendall(bytes_read)
        print("File '" + filename + "' was successfully sent.")

    # ! WARNING: PROBABLY NEED TO CLOSE THIS
<<<<<<< HEAD
    # s.close()
>>>>>>> 9c54801 (Add some comments with VSCode Extension BetterComments)
=======
    s.close()
>>>>>>> 2247660 (Remove tqdm progress bar for sending.)


#######################################
#            Receive File             #
#######################################
<<<<<<< HEAD
def receive_file(message):
    SEPARATOR = "<SEPARATOR>"

    filename, filesize, contents = message.decode().split(SEPARATOR)
=======
def receive_file():
    # device's IP address
    SERVER_HOST = HOST_IP
    SERVER_PORT = 5001
    BUFFER_SIZE = 4096  # receive 4096 bytes each time
    SEPARATOR = "<SEPARATOR>"

    # create the server socket
    s = socket.socket()

    # bind the socket to our local address
    s.bind((SERVER_HOST, SERVER_PORT))

    # enabling our server to accept connections
    s.listen(5)
    print(f"[*] Listening as {SERVER_HOST}:{SERVER_PORT}")

    # accept connection if there is any
    client_socket, address = s.accept()
    # if below code is executed, that means the sender is connected
    print(f"[+] {address} is connected.")

    # receive the file infos
    # receive using client socket, not server socket
    received = client_socket.recv(BUFFER_SIZE).decode()
    filename, filesize = received.split(SEPARATOR)
    # remove absolute path if there is
>>>>>>> 9c54801 (Add some comments with VSCode Extension BetterComments)
    filename = os.path.basename(filename)

    # Filesize is not actually used. TODO: Remove.
    filesize = int(filesize)
    filesize += 1

<<<<<<< HEAD
    # TODO: Test sending/receiving files greater than 4096 bytes large.
=======
    # start receiving the file from the socket and writing to the file stream
<<<<<<< HEAD
    progress = tqdm.tqdm(range(
        filesize), "...", unit="B", unit_scale=True, unit_divisor=1024)
>>>>>>> 2247660 (Remove tqdm progress bar for sending.)
    with open(filename, "wb") as f:
<<<<<<< HEAD
        f.write(contents.encode())
        print("File '" + filename + "' was successfully received.")
=======
        for _ in progress:
            # read 1024 bytes from the socket (receive)
            bytes_read = client_socket.recv(BUFFER_SIZE)
=======
    # read 1024 bytes from the socket (receive)
>>>>>>> abf0bd6 (remove progress bar from receive_file(), there is a connection error in line 617)

    # NOTE: test sending/receiving files greater than 4096 bytes large to see
    # if it works
    with open(filename, "wb") as f:
        bytes_read = client_socket.recv(BUFFER_SIZE)

#        if not bytes_read:
            # file transmitting is done
#            break

        # write to the file the bytes we just received
        f.write(bytes_read)
    
        print("File '" + filename + "' was successfully received.")

    # ! WARNING: PROBABLY NEED TO CLOSE THIS
<<<<<<< HEAD
    # client_socket.close()
    # s.close()
>>>>>>> 9c54801 (Add some comments with VSCode Extension BetterComments)
=======
    client_socket.close()
    s.close()
>>>>>>> 2247660 (Remove tqdm progress bar for sending.)

#######################################
#               Driver                #
#######################################


def establishConnection():
    # find own ip
    init_ip()
    tcp_listen = 9990 #if switch_ports else 9995
    tcp_port = 9995 #if switch_ports else 9990

    # broadcast to other users that you exist
    tcp_listener_worker = Process(target=tcp_listener,
                                  name="tcp_listener_worker",
                                  args=(tcp_listen,))

    tcp_listener_worker.start()
    print("Connection established.")

    return tcp_port, tcp_listener_worker


def sendEmail(tcp_port):
    tcp_client(tcp_port, getEmailFromCredentials())


def sendEmailRequest(tcp_port):
    tcp_client(tcp_port, "Requesting Email.")

<<<<<<< HEAD
<<<<<<< HEAD
def sendEmail(tcp_port):
    tcp_client(tcp_port, getEmailFromCredentials())


def killProcesses(procs):
    for p in procs:
        print("Terminating: {}".format(p.name))
=======
=======

<<<<<<< HEAD
>>>>>>> d29135a (Update)
def killProcesses(p):
    if p.is_alive():
        p.terminate()
        print("Process terminated.")
    if not p.is_alive():
        p.join()

=======
def killProcesses(procs):
    for p in procs:
        print("Terminating: {}".format(p.name))
        if p.is_alive():
            p.terminate()
            sleep(0.1)
        if not p.is_alive():
            p.join()
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)

'''
def contacts_communication_manager(switch_ports=False):
    # find own ip
    init_ip()
    #bcast_port = 1337 if switch_ports else 1338
    tcp_listen = 9990 if switch_ports else 9995
    tcp_port = 9995 if switch_ports else 9990

    # broadcast to other users that you exist
    
    broadcast_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    broadcast_socket.bind(('', bcast_port))

    broadcast_listener_worker = Process(target=broadcast_listener,
                                        name="broadcast_listener_worker",
                                        args=(broadcast_socket,))

    broadcast_sender_worker = Process(target=broadcast_sender,
                                      name="broadcast_sender_worker",
                                      args=(bcast_port,))

    tcp_listener_worker = Process(target=tcp_listener,
                                  name="tcp_listener_worker",
                                  args=(tcp_listen,))

    procs = [
        # broadcast_listener_worker,
        # broadcast_sender_worker,
        tcp_listener_worker,
    ]

    for p in procs:
        #print("Starting: {}".format(p.name))
        p.start()
        tcp_client(tcp_port, getEmailFromCredentials())

    for p in procs:
        #print("Terminating: {}".format(p.name))
>>>>>>> d1e287e (Fix listing port issue)
        if p.is_alive():
            p.terminate()
            sleep(0.1)
        if not p.is_alive():
            p.join()

<<<<<<< HEAD
<<<<<<< HEAD

def communication_manager():
=======
=======

>>>>>>> d29135a (Update)
'''
<<<<<<< HEAD
def communication_manager(switch_ports=False):
>>>>>>> d1e287e (Fix listing port issue)
    # find own ip
    init_ip()
    bcast_port = 5001
    tcp_port = 6001
=======
def communication_manager():
    # find own ip
    init_ip()
    bcast_port = 1337 #if switch_ports else 1338
    tcp_listen = 9990 #if switch_ports else 9995
    tcp_port = 9995 #if switch_ports else 9990
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)

    # broadcast to other users that you exist
    #broadcast_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    #broadcast_socket.bind(('', bcast_port))

    broadcast_sender_worker = Process(target=broadcast_sender,
                                      name="broadcast_sender_worker",
                                      args=(bcast_port,))

    tcp_listener_worker = Process(target=tcp_listener,
                                  name="tcp_listener_worker",
                                  args=(tcp_port,))

    #    receive_file_worker = Process(target=receive_file,
#                                  name="receive_file_worker",)

    procs = [
        # broadcast_listener_worker,
        broadcast_sender_worker,
        tcp_listener_worker,
#        receive_file_worker,
    ]

    try:
        for p in procs:
            #print("Starting: {}".format(p.name))
            p.start()

        # while True:
            #tcp_client(tcp_port, input(), '172.17.0.4')
            # sleep(1)

    except KeyboardInterrupt:
        for p in procs:
            print("Terminating: {}".format(p.name))
            if p.is_alive():
                p.terminate()
                sleep(0.1)
            if not p.is_alive():
                print(p.join())

# # # # #    9. MAIN    # # # # #


def main():
    try:
        _create_unverified_https_context = ssl._create_unverified_context
    except AttributeError:
        # Legacy Python that doesn't verify HTTPS certificates by default
        pass
    else:
        # Handle target environment that doesn't support HTTPS verification
        ssl._create_default_https_context = _create_unverified_https_context

    # credentials.txt is the file that contains user credentials
    touch("credentials.txt")
    chmod("credentials.txt", 0o600)

    # if the credentials.txt file is empty, prompt user registration
    if os.path.getsize("credentials.txt") == 0:
        print("No users are registered with this client.")

    if query_binary("Do you want to register a new user"):
        registerNewUser()

    # prompt log in
    if query_binary("Do you want to log in"):
        if logIn():
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
            # Start two threads - comm_manager & secureDropShell
            # 1. Start comm_manager
            th_comm_manager = Thread(target=communication_manager, daemon=True)

            th_comm_manager.start()
            th_comm_manager.join()
            # th_comm_manager.join()

            '''
            if KeyboardInterrupt:
                if th_comm_manager.is_alive():
                    th_comm_manager.terminate()
            '''
            # 2. Shell - Supports add, list, send, exit, help
            #th_secureDropShell = Thread(target=secureDropShell)
            # th_secureDropShell.start()
=======
=======
            if len(sys.argv) > 1:
                port, p = establishConnection()
            else:
                port, p = establishConnection(True)
            secureDropShell()
            killProcesses(p)
>>>>>>> d1e287e (Fix listing port issue)
            # * Start two threads - receive_files & secureDropShell
            '''
            # 1. Receive files
            th_receive_file = Thread(target=receive_file, daemon=True)
            th_receive_file.start()
=======
            # Start two threads - comm_manager & secureDropShell
            
            # 1. Start comm_manager
            th_comm_manager = Thread(target=communication_manager, daemon=True)

            th_comm_manager.start()
<<<<<<< HEAD
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)

            # 2. Shell - Supports add, list, send, exit, help
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
>>>>>>> 9c54801 (Add some comments with VSCode Extension BetterComments)
            th_secureDropShell = Thread(target=secureDropShell)
            th_secureDropShell.start()
=======
 #           th_secureDropShell = Thread(target=secureDropShell)
 #           th_secureDropShell.start()
=======
         #           th_secureDropShell = Thread(target=secureDropShell)
         #           th_secureDropShell.start()
>>>>>>> bd75a18 (Found out the problem. We need to store data captured in a seperate file (maybe a temp file))
            secureDropShell()
>>>>>>> dd7f64f (work in progress: capture messages)
=======
            th_secureDropShell = Thread(target=secureDropShell)
            th_secureDropShell.start()
<<<<<<< HEAD
            '''

            # secureDropShell()
>>>>>>> 2247660 (Remove tqdm progress bar for sending.)
=======
>>>>>>> de87437 (Fix broadcasting, rm switch_ports, multithreading in main)
=======
            th_comm_manager.join()
            '''
            if KeyboardInterrupt:
                if th_comm_manager.is_alive():
                    th_comm_manager.terminate()
            '''
            # 2. Shell - Supports add, list, send, exit, help
            #th_secureDropShell = Thread(target=secureDropShell)
            #th_secureDropShell.start()
>>>>>>> 80442f2 (Test threading)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print('Interrupted')
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
