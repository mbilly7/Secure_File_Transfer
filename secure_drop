#!/usr/bin/env python3

from email_validator import validate_email, EmailNotValidError
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import _pickle as cPickle
import bcrypt
import json
import os
import re
import sys
import ssl
import socket
from time import sleep
from multiprocessing import Process
from socketserver import BaseRequestHandler, TCPServer
import getpass
import subprocess
from threading import Thread
from os import chmod

own_ip = None
SYMM_KEY = "stub"
#HOST_IP_1 = "127.0.0.2"
HOST_IP_2 = "172.17.0.3"
HOST_IP_3 = "172.17.0.4"

MSG = "temp"

# # # # # 1. SHELL COMMANDS # # # # #


def secureDropShell():
    while True:
        inp = input("secure_drop> ")
        if inp == "exit":
            break
        elif inp[:3] == "cd ":
            shell_cd(inp[3:])
        elif inp == "help":
            shell_help()
        elif inp == "add":
            shell_add()
        elif inp == "list":
            shell_list()
        elif inp == "send":
            shell_send()
        else:
            execute_command(inp)
        '''
        elif inp[:5] == "send ":
            words = inp.split()

            email_valid = False
            file_path_valid = False

            email = words[1]
            file_path = words[2]

            print(email)  # debug
            print(file_path)  # debug

            # Check if email is contacts
            if os.path.getsize("contacts.bin") > 0:
                if not isInContacts(email):
                    print("provided email address is not in your contacts list")
                else:
                    email_valid = True
                    print("email correct")  # debug
            try:
                if os.path.getsize(file_path) == 0:  # change criteria later?
                    print("provided file is empty")
                else:
                    file_path_valid = True
                    print("file correct")  # debug

            except FileNotFoundError:
                print("provided file path does not exist")

            if email_valid and file_path_valid:
                shell_send(email, file_path)
            else:
                print("there was an error with either the email address or the file")
        '''


def shell_cd(path):
    """convert to absolute path and change directory"""
    try:
        os.chdir(os.path.abspath(path))
    except Exception:
        print("cd: no such file or directory: {}".format(path))


def shell_help():
    print('  "add"  -> Add a new contact')
    print('  "list" -> List all online contacts')
    print('  "send" -> Transfer file to contact')
    print('  "exit" -> Exit SecureDrop')


def shell_add():
    name = getName()
    email = getEmail()
    storeData(name, email, "contacts.txt")
    print("  Contact Added.")


def shell_list():
    if os.path.getsize("contacts.bin") > 0:
        broadcast_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        broadcast_socket.bind(('', 5000))

        broadcast_listener_worker = Process(target=broadcast_listener,
                                            name="broadcast_listener_worker",
                                            args=(broadcast_socket,))

        try:
            broadcast_listener_worker.start()
            print("Starting ".format(broadcast_listener_worker.name))
            
        except KeyboardInterrupt:
            if broadcast_listener_worker.is_alive():
                broadcast_listener_worker.terminate()
            if not broadcast_listener_worker.is_alive():
                broadcast_listener_worker.join()
    else:
        print("You have no contacts.")


def shell_send(email, file_path):
    # send_file(file_path)
    tcp_client(9990, input())


def execute_command(command):
    """execute commands and handle piping"""
    try:
        if "|" in command:
            # save for restoring later on
            s_in, s_out = (0, 0)
            s_in = os.dup(0)
            s_out = os.dup(1)

            # first command takes commandut from stdin
            fdin = os.dup(s_in)

            # iterate over all the commands that are piped
            for cmd in command.split("|"):
                # fdin will be stdin if it's the first iteration
                # and the readable end of the pipe if not.
                os.dup2(fdin, 0)
                os.close(fdin)

                # restore stdout if this is the last command
                if cmd == command.split("|")[-1]:
                    fdout = os.dup(s_out)
                else:
                    fdin, fdout = os.pipe()

                # redirect stdout to pipe
                os.dup2(fdout, 1)
                os.close(fdout)

                try:
                    subprocess.run(cmd.strip().split())
                except Exception:
                    print("psh: command not found: {}".format(cmd.strip()))

            # restore stdout and stdin
            os.dup2(s_in, 0)
            os.dup2(s_out, 1)
            os.close(s_in)
            os.close(s_out)
        else:
            subprocess.run(command.split(" "))
    except Exception:
        print("psh: command not found: {}".format(command))

# # # # # 2. Credentials # # # # #


def getEmail():
    while True:
        try:
            email = str(input("Enter Email Address: "))
            validate_email(email)
            return email
        except EmailNotValidError as e:
            print(str(e))
            continue
        else:
            break


def getName():
    name = input("Enter Full Name: ")
    while not all(x.isalpha() or x.isspace() for x in name) or len(name) == 0:
        print("Invalid Name. Try again.")
        name = input("Enter Full Name: ")
    return name

# # # # # 3. Password # # # # #


def setPassword():
    password = getpass.getpass()
    while not passwordMeetsRequirements(password):
        print("""Password must be 6-20 characters long and requires at least one: 
    number, uppercase letter, lowercase letter, and special symbol. Try again.""")
        password = getpass.getpass()

    password_copy = getpass.getpass("Re-enter Password: ")
    if password_copy != password:
        print("Passwords do not match. Try again.")
        password = setPassword()
    return password


def getPassword():
    password = getpass.getpass()
    return password


def getHashedPassword(password):
    # CHANGE TO 16 IN FINAL PRODUCT
    return bcrypt.hashpw(password.encode("utf8"), bcrypt.gensalt(12))


def passwordMeetsRequirements(password):
    reg = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!#%*?&]{6,20}$"
    return re.search(re.compile(reg), password)


def checkPassword(password, hashed_password):
    """
    :param password: the string representation of the password in plain-text or None
    :type password: str or None
    :param hashed_password: the string representation of the hashed password
    :type hashed_password: str
    :returns: True if the password is correct or False if the password is incorrect
    :rtype: bool
    """
    if password is None:
        return False
    return bcrypt.checkpw(password.encode("utf8"), hashed_password.encode("utf8"))


# # # # # 4. Logging In # # # # #


def logIn():
    global SYMM_KEY
    successful = False
    if os.path.getsize("credentials.txt") > 0:
        touch("contacts.bin")
        chmod("contacts.bin", 0o600)
        email = getEmail()
        password = getPassword()

        # check password correctness by parsing credentials.txt
        with open("credentials.txt") as json_file:
            data = json.load(json_file)
            for user in data["users"]:
                if user["email"] == email and checkPassword(password, user["password"]):
                    SYMM_KEY = user["password"][3:19].encode("utf-8")
                    # successful
                    print("Passwords Match.")
                    print("Logging In.")
                    successful = True
                    # *TODO: Enter shell
                if not successful:
                    print("Incorrect Credentials. Try again.")
                    successful = logIn()
    else:
        print("There are no users registered")

    return successful


def storeUserInfo(name, email, password):
    """
    returns the dict of dict that constitutes the user info
    the outer dictionary maps the string "users" to a dictionary
    the inner dictionary maps the strings "name", "email", and "password" to strings for all three of these
    """
    data = {}
    data["users"] = []

    user_dict = {}

    user_dict["name"] = name
    user_dict["email"] = email
    user_dict["password"] = getHashedPassword(password).decode("utf-8")

    data["users"].append(user_dict)
    return data

# # # # # 5. Database # # # # #


def storeData(name, email, filename):
    global SYMM_KEY
    if os.path.getsize("contacts.bin") > 0:
        aesDecryptFile("contacts.bin", SYMM_KEY)
    else:
        touch("contacts.txt")
        chmod("contacts.txt", 0o600)

    db = {}

    newContact = {'name': name, 'email': email}

    db[name] = newContact

    dbfile = open(filename, 'ab')

    cPickle.dump(db, dbfile)
    dbfile.close()

    aesEncryptFile(filename, SYMM_KEY)


def isInContacts(data):
    exists = False
    contacts = getObjs("contacts.txt")
    for x in contacts:
        for y in x:
            if x[y]["email"] == data:
                exists = True
    return exists


def getEmailFromCredentials():
    with open("credentials.txt") as json_file:
        data = json.load(json_file)
        for user in data["users"]:
            email = user["email"]
    return email


def getObjs(filename):
    global SYMM_KEY
    aesDecryptFile("contacts.bin", SYMM_KEY)

    objs = []

    with (open(filename, "rb")) as dbfile:
        while True:
            try:
                objs.append(cPickle.load(dbfile))
            except EOFError:
                break

    dbfile.close()

    aesEncryptFile("contacts.txt", SYMM_KEY)
    return objs


def loadData(filename):
    global SYMM_KEY
    aesDecryptFile("contacts.bin", SYMM_KEY)

    objs = []

    with (open(filename, "rb")) as dbfile:
        while True:
            try:
                objs.append(cPickle.load(dbfile))
            except EOFError:
                break

    print(objs)
    dbfile.close()

    aesEncryptFile("contacts.txt", SYMM_KEY)


def loadDataForSend(filename, email):
    global SYMM_KEY
    aesDecryptFile("contacts.bin", SYMM_KEY)

    objs = []

    with (open(filename, "rb")) as dbfile:
        while True:
            try:
                objs.append(cPickle.load(dbfile))
            except EOFError:
                break

    if email in str(objs[0]):
        print(str(objs[0]))
        print("it's in here")
        return True
    else:
        print(str(objs[0]))
        print("it's not in here")
        return False
    dbfile.close()

    aesEncryptFile("contacts.txt", SYMM_KEY)

    print(objs)


def registerNewUser():
    if os.path.exists("contacts.bin"):
        os.remove("contacts.bin")

    print("The user registration is a one-time process. Once a user is registered on a client, the"
          " login module is activated subsequently. After a successful login, a \"secure_drop>\" shell"
          " is started.")

    name = getName()
    email = str(getEmail())
    password = setPassword()

    dumpRegisterToTextFile(storeUserInfo(
        name, email, password), "credentials.txt")


def dumpUserToTextFile(data, file_name):
    """
    data is a dict of dict
    """
    with open(file_name, "w") as outfile:
        cPickle.dump(data, outfile)


def dumpRegisterToTextFile(data, file_name):
    with open(file_name, "w") as outfile:
        json.dump(data, outfile)


def printDataFile():
    with open("credentials.txt") as json_file:
        data = json.load(json_file)
        for u in data["users"]:
            print()
            print("Name: " + u["name"])
            print("Email: " + u["email"])
            print("Password: " + u["password"])


# # # # # 6. Helper Functions # # # # #

def query_binary(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        print(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            print("Please respond with 'yes' or 'no' "
                  "(or 'y' or 'n').")


def touch(fname):
    if os.path.exists(fname):
        os.utime(fname, None)
    else:
        open(fname, 'a').close()


# # # # # 7. Encryption # # # # #

def aesEncryptFile(file_name, key):
    cipher = AES.new(key, AES.MODE_EAX)
    data = open(file_name, 'rb').read()
    ciphertext, tag = cipher.encrypt_and_digest(data)

    file_name = file_name.replace(".txt", "")
    file_name += ".bin"
    file_out = open(file_name, "wb")
    [file_out.write(x) for x in (cipher.nonce, tag, ciphertext)]
    file_out.close()
    chmod(file_name, 0o600)
    os.remove("contacts.txt")


def aesDecryptFile(file_name, key):
    file_in = open(file_name, "rb")
    nonce, tag, ciphertext = [file_in.read(x) for x in (16, 16, -1)]
    cipher = AES.new(key, AES.MODE_EAX, nonce)
    file_name = file_name.replace(".bin", "")
    file_name += ".txt"
    file_out = open(file_name, "wb")
    file_out.write(cipher.decrypt_and_verify(ciphertext, tag))
    chmod(file_name, 0o600)
    return file_name


def init_ip():
    global own_ip
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.connect(("8.8.8.8", 80))
    own_ip = s.getsockname()[0]
    #host = "localhost"
    s.close()


#######################################
#             TCP example             #
#######################################
class tcp_handler(BaseRequestHandler):
    def handle(self):
        self.data = self.request.recv(1024).strip()
        print("Echoing message from: {}".format(self.client_address[0]))
        print(self.data)
        self.request.sendall("ACK from server".encode())


def tcp_listener(port):
    global own_ip
    host = own_ip
    #cntx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
    #cntx.load_cert_chain('cert.pem', 'cert.pem')

    server = TCPServer((host, port), tcp_handler)
    #server.socket = cntx.wrap_socket(server.socket, server_side=True)
    try:
        server.serve_forever()
    except:
        print("listener shutting down")
        server.shutdown()


def tcp_client(port, data):
    # TODO: MAYBE CHANGE host_ip TO DOCKER CONTAINER IP
    #host_ip = "127.0.0.1"
    host_ip = "172.17.0.3"

    # Initialize a TCP client socket using SOCK_STREAM
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    #cntx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    # cntx.load_verify_locations('cert.pem')
    # cntx.load_cert_chain('cert.pem')

    #s = cntx.wrap_socket(s, server_hostname='test.server')

    try:
        # Establish connection to TCP server and exchange data
        # TODO: FIX ERROR RELATED TO THE FOLLOWING LINE
        s.connect((host_ip, port))
        s.sendall(data.encode())
        # Read data from the TCP server and close the connection
        received = s.recv(1024)
    finally:
        s.close()

    print("Bytes Sent:     {}".format(data))
    print("Bytes Received: {}".format(received.decode()))


#######################################
#          Broadcast Example          #
#######################################
def broadcast_listener(socket):
    try:
        while True:
            data = socket.recvfrom(512)
            print(data)
    except KeyboardInterrupt:
        pass


def broadcast_sender(port):
    count = 0
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        while True:
            msg = 'Broadcast from SecureDrop User: ' + getEmailFromCredentials()
            s.sendto(msg.encode('ascii'), ('255.255.255.255', port))
            sleep(5)
    except KeyboardInterrupt:
        pass

#######################################
#             Send File               #
#######################################


def send_file(file_path):
    SEPARATOR = "<SEPARATOR>"
    BUFFER_SIZE = 4096  # send 4096 bytes each time step

    # * receiver IP Address and Port
    host = HOST_IP
    print("IMPORTANT!")
    print(len(sys.argv))
    if len(sys.argv) > 1:
        port = 5001
    else:
        port = 5002

    # the name of file we want to send, make sure it exists
    filename = file_path
    filesize = os.path.getsize(filename)

    # create the client socket
    s = socket.socket()

    print(f"[+] Connecting to {host}:{port}")
    s.connect((host, port))
    print("[+] Connected.")

    # send the filename and filesize
    s.send(f"{filename}{SEPARATOR}{filesize}".encode())

    # * start sending the file
    with open(filename, "rb") as f:
        # read the bytes from the file
        bytes_read = f.read(BUFFER_SIZE)

        # send file
        s.sendall(bytes_read)
        print("File '" + filename + "' was successfully sent.")

    # ! WARNING: PROBABLY NEED TO CLOSE THIS
    s.close()


#######################################
#            Receive File             #
#######################################
def receive_file():
    # device's IP address
    SERVER_HOST = HOST_IP
    SERVER_PORT = 5001
    BUFFER_SIZE = 4096  # receive 4096 bytes each time
    SEPARATOR = "<SEPARATOR>"

    # create the server socket
    s = socket.socket()

    # bind the socket to our local address
    s.bind((SERVER_HOST, SERVER_PORT))

    # enabling our server to accept connections
    s.listen(5)
    print(f"[*] Listening as {SERVER_HOST}:{SERVER_PORT}")

    # accept connection if there is any
    client_socket, address = s.accept()
    # if below code is executed, that means the sender is connected
    print(f"[+] {address} is connected.")

    # receive the file infos
    # receive using client socket, not server socket
    received = client_socket.recv(BUFFER_SIZE).decode()
    filename, filesize = received.split(SEPARATOR)
    # remove absolute path if there is
    filename = os.path.basename(filename)
    # convert to integer
    filesize = int(filesize)

    # start receiving the file from the socket and writing to the file stream
    # read 1024 bytes from the socket (receive)

    # NOTE: test sending/receiving files greater than 4096 bytes large to see
    # if it works
    with open(filename, "wb") as f:
        bytes_read = client_socket.recv(BUFFER_SIZE)

        # write to the file the bytes we just received
        f.write(bytes_read)

        print("File '" + filename + "' was successfully received.")

    # ! WARNING: PROBABLY NEED TO CLOSE THIS
    client_socket.close()
    s.close()

#######################################
#               Driver                #
#######################################


def establishConnection():
    # find own ip
    init_ip()
    tcp_listen = 9990  # if switch_ports else 9995
    tcp_port = 9995  # if switch_ports else 9990

    # broadcast to other users that you exist
    tcp_listener_worker = Process(target=tcp_listener,
                                  name="tcp_listener_worker",
                                  args=(tcp_listen,))

    tcp_listener_worker.start()
    print("Connection established.")

    return tcp_port, tcp_listener_worker


def sendEmail(tcp_port):
    tcp_client(tcp_port, getEmailFromCredentials())


def sendEmailRequest(tcp_port):
    tcp_client(tcp_port, "Requesting Email.")


def killProcesses(procs):
    for p in procs:
        print("Terminating: {}".format(p.name))
        if p.is_alive():
            p.terminate()
            sleep(0.1)
        if not p.is_alive():
            p.join()


def communication_manager():
    # find own ip
    init_ip()
    bcast_port = 1337  # if switch_ports else 1338
    tcp_listen = 9990  # if switch_ports else 9995
    tcp_port = 9990  # if switch_ports else 9990

    # broadcast to other users that you exist
    #broadcast_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    #broadcast_socket.bind(('', bcast_port))

    broadcast_sender_worker = Process(target=broadcast_sender,
                                      name="broadcast_sender_worker",
                                      args=(bcast_port,))

    tcp_listener_worker = Process(target=tcp_listener,
                                  name="tcp_listener_worker",
                                  args=(tcp_listen,))

    procs = [
        # broadcast_listener_worker,
        broadcast_sender_worker,
        tcp_listener_worker,
    ]

    try:
        for p in procs:
            #print("Starting: {}".format(p.name))
            p.start()
        '''
        while True:
            tcp_client(tcp_port, input())
            sleep(1)
        '''

    except KeyboardInterrupt:
        for p in procs:
            print("Terminating: {}".format(p.name))
            if p.is_alive():
                p.terminate()
                sleep(0.1)
            if not p.is_alive():
                print(p.join())

# # # # #    9. MAIN    # # # # #


def main():

    # credentials.txt is the file that contains user credentials
    touch("credentials.txt")
    chmod("credentials.txt", 0o600)

    # if the credentials.txt file is empty, prompt user registration
    if os.path.getsize("credentials.txt") == 0:
        print("No users are registered with this client.")

    if query_binary("Do you want to register a new user (y/n)? "):
        registerNewUser()

    # prompt log in
    if query_binary("Do you want to log in (y/n)? "):
        if logIn():
            # Start two threads - comm_manager & secureDropShell
            # 1. Start comm_manager
            th_comm_manager = Thread(target=communication_manager, daemon=True)

            th_comm_manager.start()
            th_comm_manager.join()
            # th_comm_manager.join()

            '''
            if KeyboardInterrupt:
                if th_comm_manager.is_alive():
                    th_comm_manager.terminate()
            '''
            # 2. Shell - Supports add, list, send, exit, help
            #th_secureDropShell = Thread(target=secureDropShell)
            # th_secureDropShell.start()
            th_secureDropShell = Thread(target=secureDropShell)
            th_secureDropShell.start()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print('Interrupted')
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
