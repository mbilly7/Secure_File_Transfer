#!/usr/bin/env python3

from email_validator import validate_email, EmailNotValidError
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
import _pickle as cPickle
import bcrypt
import json
import os
import re
import sys
import getpass
import subprocess
from os import chmod

SYMM_KEY = "stub"

# # # # # 1. SHELL COMMANDS # # # # #


def secureDropShell():
    while True:
        inp = input("secure_drop> ")
        if inp == "exit":
            break
        elif inp[:3] == "cd ":
            psh_cd(inp[3:])
        elif inp == "help":
            psh_help()
        elif inp == "add":
            psh_add()
        elif inp == "list":
            psh_list()
        elif inp == "send":
            psh_send()
        else:
            execute_command(inp)


def psh_cd(path):
    """convert to absolute path and change directory"""
    try:
        os.chdir(os.path.abspath(path))
    except Exception:
        print("cd: no such file or directory: {}".format(path))


def psh_help():
    print('  "add"  -> Add a new contact')
    print('  "list" -> List all online contacts')
    print('  "send" -> Transfer file to contact')
    print('  "exit" -> Exit SecureDrop')


def psh_add():
    name = getName()
    email = getEmail()
    storeData(name, email, "contacts.txt")
    print("  Contact Added.")


def psh_list():
    print("  Listing!")
    if os.path.getsize("contacts.bin") > 0:
        loadData("contacts.txt")
    else:
        print("You have no contacts.")


def psh_send():
    print("  Sending!")


def execute_command(command):
    """execute commands and handle piping"""
    try:
        if "|" in command:
            # save for restoring later on
            s_in, s_out = (0, 0)
            s_in = os.dup(0)
            s_out = os.dup(1)

            # first command takes commandut from stdin
            fdin = os.dup(s_in)

            # iterate over all the commands that are piped
            for cmd in command.split("|"):
                # fdin will be stdin if it's the first iteration
                # and the readable end of the pipe if not.
                os.dup2(fdin, 0)
                os.close(fdin)

                # restore stdout if this is the last command
                if cmd == command.split("|")[-1]:
                    fdout = os.dup(s_out)
                else:
                    fdin, fdout = os.pipe()

                # redirect stdout to pipe
                os.dup2(fdout, 1)
                os.close(fdout)

                try:
                    subprocess.run(cmd.strip().split())
                except Exception:
                    print("psh: command not found: {}".format(cmd.strip()))

            # restore stdout and stdin
            os.dup2(s_in, 0)
            os.dup2(s_out, 1)
            os.close(s_in)
            os.close(s_out)
        else:
            subprocess.run(command.split(" "))
    except Exception:
        print("psh: command not found: {}".format(command))

# # # # # 2. Credentials # # # # #


def getEmail():
    while True:
        try:
            email = str(input("Enter Email Address: "))
            validate_email(email)
            return email
        except EmailNotValidError as e:
            print(str(e))
            continue
        else:
            break


def getName():
    name = input("Enter Full Name: ")
    while not all(x.isalpha() or x.isspace() for x in name) or len(name) == 0:
        print("Invalid Name. Try again.")
        name = input("Enter Full Name: ")
    return name

# # # # # 3. Password # # # # #


def setPassword():
    password = getpass.getpass()
    while not passwordMeetsRequirements(password):
        print("""Password must be 6-20 characters long and requires at least one: 
    number, uppercase letter, lowercase letter, and special symbol. Try again.""")
        password = getpass.getpass()

    password_copy = getpass.getpass("Re-enter Password: ")
    if password_copy != password:
        print("Passwords do not match. Try again.")
        password = setPassword()
    return password


def getPassword():
    password = getpass.getpass()
    return password


def getHashedPassword(password):
    return bcrypt.hashpw(password.encode("utf8"), bcrypt.gensalt(16))


def passwordMeetsRequirements(password):
    reg = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!#%*?&]{6,20}$"
    return re.search(re.compile(reg), password)


def checkPassword(password, hashed_password):
    """
    :param password: the string representation of the password in plain-text or None
    :type password: str or None
    :param hashed_password: the string representation of the hashed password
    :type hashed_password: str
    :returns: True if the password is correct or False if the password is incorrect
    :rtype: bool
    """
    if password is None:
        return False
    return bcrypt.checkpw(password.encode("utf8"), hashed_password.encode("utf8"))


# # # # # 4. Logging In # # # # #


def logIn():
    global SYMM_KEY
    successful = False
    if os.path.getsize("credentials.txt") > 0:
        touch("contacts.bin")
        chmod("contacts.bin", 0o600)
        email = getEmail()
        password = getPassword()

        # check password correctness by parsing credentials.txt
        with open("credentials.txt") as json_file:
            data = json.load(json_file)
            for user in data["users"]:
                if user["email"] == email and checkPassword(password, user["password"]):
                    SYMM_KEY = user["password"][3:19].encode("utf-8")
                    # successful
                    print("Passwords Match.")
                    print("Logging In.")
                    successful = True
                    # call function to enter shell TODO
                    # unsuccessful
                    if not successful:
                        print("Incorrect Credentials. Try again.")
                        logIn()
    else:
        print("There are no users registered")

    return successful


def storeUserInfo(name, email, password):
    """
    returns the dict of dict that constitutes the user info
    the outer dictionary maps the string "users" to a dictionary
    the inner dictionary maps the strings "name", "email", and "password" to strings for all three of these
    """
    data = {}
    data["users"] = []

    user_dict = {}

    user_dict["name"] = name
    user_dict["email"] = email
    user_dict["password"] = getHashedPassword(password).decode("utf-8")

    data["users"].append(user_dict)
    return data

# # # # # 5. Database # # # # #


def storeData(name, email, filename):
    global SYMM_KEY
    if os.path.getsize("contacts.bin") > 0:
        aesDecryptFile("contacts.bin", SYMM_KEY)
    else:
        touch("contacts.txt")
        chmod("contacts.txt", 0o600)

    db = {}

    newContact = {'name': name, 'email': email}

    db[name] = newContact

    dbfile = open(filename, 'ab')

    cPickle.dump(db, dbfile)
    dbfile.close()

    aesEncryptFile(filename, SYMM_KEY)


def loadData(filename):
    global SYMM_KEY
    aesDecryptFile("contacts.bin", SYMM_KEY)

    objs = []

    with (open(filename, "rb")) as dbfile:
        while True:
            try:
                objs.append(cPickle.load(dbfile))
            except EOFError:
                break

    print(objs)
    dbfile.close()

    aesEncryptFile("contacts.txt", SYMM_KEY)


def registerNewUser():
    if os.path.exists("contacts.bin"):
        os.remove("contacts.bin")

    print("The user registration is a one-time process. Once a user is registered on a client, the"
          " login module is activated subsequently. After a successful login, a \"secure_drop>\" shell"
          " is started.")

    name = getName()
    email = str(getEmail())
    password = setPassword()

    dumpRegisterToTextFile(storeUserInfo(
        name, email, password), "credentials.txt")


def dumpUserToTextFile(data, file_name):
    """
    data is a dict of dict
    """
    with open(file_name, "w") as outfile:
        cPickle.dump(data, outfile)


def dumpRegisterToTextFile(data, file_name):
    with open(file_name, "w") as outfile:
        json.dump(data, outfile)


def printDataFile():
    with open("credentials.txt") as json_file:
        data = json.load(json_file)
        for u in data["users"]:
            print()
            print("Name: " + u["name"])
            print("Email: " + u["email"])
            print("Password: " + u["password"])


# # # # # 6. Helper Functions # # # # #

def query_binary(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        print(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            print("Please respond with 'yes' or 'no' "
                  "(or 'y' or 'n').")


def touch(fname):
    if os.path.exists(fname):
        os.utime(fname, None)
    else:
        open(fname, 'a').close()


# # # # # 7. Encryption # # # # #

def aesEncryptFile(file_name, key):
    cipher = AES.new(key, AES.MODE_EAX)
    data = open(file_name, 'rb').read()
    ciphertext, tag = cipher.encrypt_and_digest(data)

    file_name = file_name.replace(".txt", "")
    file_name += ".bin"
    file_out = open(file_name, "wb")
    [file_out.write(x) for x in (cipher.nonce, tag, ciphertext)]
    file_out.close()
    chmod(file_name, 0o600)
    os.remove("contacts.txt")


def aesDecryptFile(file_name, key):
    file_in = open(file_name, "rb")
    nonce, tag, ciphertext = [file_in.read(x) for x in (16, 16, -1)]
    cipher = AES.new(key, AES.MODE_EAX, nonce)
    file_name = file_name.replace(".bin", "")
    file_name += ".txt"
    file_out = open(file_name, "wb")
    file_out.write(cipher.decrypt_and_verify(ciphertext, tag))
    chmod(file_name, 0o600)
    return file_name


# # # # #    8. MAIN    # # # # #

def main():

    # credentials.txt is the file that contains user credientials
    touch("credentials.txt")
    chmod("credentials.txt", 0o600)

    # if the credentials.txt file is empty, prompt user registration
    if os.path.getsize("credentials.txt") == 0:
        print("No users are registered with this client.")

    if query_binary("Do you want to register a new user (y/n)? "):
        registerNewUser()

    # prompt log in
    if query_binary("Do you want to log in (y/n)? "):
        if logIn():
            # Shell - Supports add, list, send, exit, help
            secureDropShell()


if __name__ == "__main__":
    sys.exit(main())
