#!/usr/bin/env python3

from email_validator import validate_email, EmailNotValidError
import _pickle as cPickle
import bcrypt
import json
import os
import re
import sys
import getpass
import subprocess


# TODO Database:
# Adding Contacts:
#  Contact already exists
#  Read all contacts from file
#
# TODO SECURITY:
# Too many attempts -> lockout
# Clean up data / encrypt data
#
# TODO BUGS:
# Checking Password - use hash
# getPassword() 1x or 2x depending on login or register
#
# POSSIBLE TODO:
# Asterisks for passwords (like PDF)
# Login - distinguish between incorrect pwd, incorrect email?


def query_binary(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        print(question + prompt)
        choice = input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            print("Please respond with 'yes' or 'no' "
                  "(or 'y' or 'n').")


def touch(fname):
    if os.path.exists(fname):
        os.utime(fname, None)
    else:
        open(fname, 'a').close()


def secureDropShell():
    while True:
        inp = input("secure_drop> ")
        if inp == "exit":
            break
        elif inp[:3] == "cd ":
            psh_cd(inp[3:])
        elif inp == "help":
            psh_help()
        elif inp == "add":
            psh_add()
        elif inp == "list":
            psh_list()
        elif inp == "send":
            psh_send()
        else:
            execute_command(inp)

# CREDENTIALS


def getEmail():
    while True:
        try:
            email = str(input("Enter Email Address: "))
            validate_email(email)
            return email
        except EmailNotValidError as e:
            print(str(e))
            continue
        else:
            break


def getName():
    name = input("Enter Full Name: ")
    while not all(x.isalpha() or x.isspace() for x in name) or len(name) == 0:
        print("Invalid Name. Try again.")
        name = input("Enter Full Name: ")
    return name


# PASSWORD


def passwordMeetsRequirements(password):
    reg = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*#?&])[A-Za-z\d@$!#%*?&]{6,20}$"
    return re.search(re.compile(reg), password)


def setPassword():
    password = getpass.getpass()
    while not passwordMeetsRequirements(password):
        print("""Password must be 6-20 characters long and requires at least one: 
    number, uppercase letter, lowercase letter, and special symbol. Try again.""")
        password = getpass.getpass()

    password_copy = getpass.getpass("Re-enter Password: ")
    if password_copy != password:
        print("Passwords do not match. Try again.")
        password = setPassword()
    return password


def getHashedPassword(password):
    return bcrypt.hashpw(password.encode("utf8"), bcrypt.gensalt(12))


def checkPassword(password, hashed_password):
    """
    :param password: the string representation of the password in plain-text or None
    :type password: str or None
    :param hashed_password: the string representation of the hashed password
    :type hashed_password: str
    :returns: True if the password is correct or False if the password is incorrect
    :rtype: bool
    """
    if password is None:
        return False
    return bcrypt.checkpw(password.encode("utf8"), hashed_password.encode("utf8"))


# DATA FILE

def dumpUserToTextFile(data, file_name):
    """
    data is a dict of dict
    """
    with open(file_name, "w") as outfile:
        cPickle.dump(data, outfile)


def dumpRegisterToTextFile(data, file_name):
    with open(file_name, "w") as outfile:
        json.dump(data, outfile)


def printDataFile():
    with open("data.txt") as json_file:
        data = json.load(json_file)
        for u in data["users"]:
            print()
            print("Name: " + u["name"])
            print("Email: " + u["email"])
            print("Password: " + u["password"])

# LOG IN


def getPassword():
    password = getpass.getpass()
    return password


def logIn():
    email = getEmail()
    password = getPassword()
    successful = False

    # check password correctness by parsing data.txt
    with open("data.txt") as json_file:
        data = json.load(json_file)
        for user in data["users"]:
            if user["email"] == email and checkPassword(password, user["password"]):
                # successful
                print("Passwords Match.")
                print("Logging In.")
                successful = True
                # call function to enter shell TODO

    # unsuccessful
    if not successful:
        print("Incorrect Credentials. Try again.")
        logIn()

# CONTACT INFO


def storeData(name, email, filename):
    db = {}

    newContact = {'name': getHashedPassword(
        name), 'email': getHashedPassword(email)}

    db[name] = newContact

    dbfile = open(filename, 'ab')

    cPickle.dump(db, dbfile)
    dbfile.close()


def loadData(filename):
    objs = []

    with (open(filename, "rb")) as dbfile:
        while True:
            try:
                objs.append(cPickle.load(dbfile))
            except EOFError:
                break

    print(objs)
    dbfile.close()

# USER INFO


def storeUserInfo(name, email, password):
    """
    returns the dict of dict that constitutes the user info
    the outer dictionary maps the string "users" to a dictionary
    the inner dictionary maps the strings "name", "email", and "password" to strings for all three of these
    """
    data = {}
    data["users"] = []

    user_dict = {}

    user_dict["name"] = name
    user_dict["email"] = email
    user_dict["password"] = getHashedPassword(password).decode("utf-8")

    data["users"].append(user_dict)
    return data


def registerNewUser():
    print("The user registration is a one-time process. Once a user is registered on a client, the"
          " login module is activated subsequently. After a successful login, a \"secure_drop>\" shell"
          " is started.")

    name = getName()
    email = str(getEmail())
    userExisted = False

    #dumpRegisterToTextFile(storeUserInfo(name, "billy@gmail.com", "password"), "data.txt")

    '''
    # check password correctness by parsing data.txt
    with open("data.txt") as json_file:
        data = json.load(json_file)
        for user in data["users"]:
            if user["email"] == email:
                print("This user already exists.")
                userExisted = True
                if query_binary("Do you want to log into your account? (y/n) "):
                    logIn()
                break

    if not userExisted:
    '''
    password = setPassword()
    dumpRegisterToTextFile(storeUserInfo(name, email, password), "data.txt")
    # printDataFile()
    '''
    else:
        print("Okay. Exiting now.")
        exit(1)
    '''


def execute_command(command):
    """execute commands and handle piping"""
    try:
        if "|" in command:
            # save for restoring later on
            s_in, s_out = (0, 0)
            s_in = os.dup(0)
            s_out = os.dup(1)

            # first command takes commandut from stdin
            fdin = os.dup(s_in)

            # iterate over all the commands that are piped
            for cmd in command.split("|"):
                # fdin will be stdin if it's the first iteration
                # and the readable end of the pipe if not.
                os.dup2(fdin, 0)
                os.close(fdin)

                # restore stdout if this is the last command
                if cmd == command.split("|")[-1]:
                    fdout = os.dup(s_out)
                else:
                    fdin, fdout = os.pipe()

                # redirect stdout to pipe
                os.dup2(fdout, 1)
                os.close(fdout)

                try:
                    subprocess.run(cmd.strip().split())
                except Exception:
                    print("psh: command not found: {}".format(cmd.strip()))

            # restore stdout and stdin
            os.dup2(s_in, 0)
            os.dup2(s_out, 1)
            os.close(s_in)
            os.close(s_out)
        else:
            subprocess.run(command.split(" "))
    except Exception:
        print("psh: command not found: {}".format(command))


def psh_cd(path):
    """convert to absolute path and change directory"""
    try:
        os.chdir(os.path.abspath(path))
    except Exception:
        print("cd: no such file or directory: {}".format(path))


# Shell commands


def psh_help():
    print('"  add"  -> Add a new contact')
    print('"  list" -> List all online contacts')
    print('"  send" -> Transfer file to contact')
    print('"  exit" -> Exit SecureDrop')


def psh_add():
    name = getName()
    email = getEmail()
    storeData(name, email, "contacts.txt")
    print("  Contact Added.")


def psh_list():
    print("  Listing!")
    loadData("contacts.txt")


def psh_send():

    print("  Sending!")

# MAIN


def main():
    # Reigstration - complete
    # data.txt is the file that contains user credientials
    touch("data.txt")
    # contacts.txt is the file the contains contacts
    touch("contacts.txt")

    # change file permissions to enhance security
    '''
    command = ["chmod", "600", "data.txt"]
    subprocess.Popen(command, stdout=subprocess.PIPE)        
    command = ["chmod", "600", "contacts.txt"]
    subprocess.Popen(command, stdout=subprocess.PIPE)   
    '''

    # if the data.txt file is empty, prompt user registration
    if os.path.getsize("data.txt") == 0:
        print("No users are registered with this client.")

    if query_binary("Do you want to register a new user (y/n)? "):
        registerNewUser()

    # prompt log in
    if query_binary("Do you want to log in (y/n)? "):
        logIn()
        # Shell - Supports add, list, send, exit, help
        secureDropShell()


if __name__ == "__main__":
    sys.exit(main())
